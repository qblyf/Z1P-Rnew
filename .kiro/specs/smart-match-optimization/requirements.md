# 智能匹配功能优化 - 需求文档

## 1. 项目概述

### 1.1 背景
当前智能匹配系统存在以下问题：
- 型号提取在匹配时动态进行，效率低下
- 匹配逻辑复杂，精确度不够
- 缺少明确的"精简度"判断标准
- 品牌+型号匹配不够直接

### 1.2 目标
优化智能匹配流程，实现：
1. **数据预处理阶段**：提前对所有SPU进行品牌、型号分离和标准化
2. **输入处理阶段**：清洗和标准化用户输入，提取结构化信息
3. **匹配阶段**：基于预处理数据进行高效的品牌+型号全字匹配
4. **优先级排序**：分数相同时，优先选择更精简的SPU

---

## 2. 用户故事

### 2.1 数据预处理
**作为** 系统管理员  
**我希望** 系统在启动时自动对所有SPU进行预处理  
**以便** 匹配时可以直接使用预处理结果，提高匹配效率

**验收标准**：
- [ ] 2.1.1 系统能从SPU名称中提取并存储品牌信息
- [ ] 2.1.2 系统能从SPU名称中提取并存储型号信息（标准化格式）
- [ ] 2.1.3 系统能从SKU中提取并存储规格信息（颜色、容量、版本）
- [ ] 2.1.4 系统能计算并存储SPU的"精简度"指标
- [ ] 2.1.5 预处理结果能持久化存储，避免重复计算

### 2.2 输入清洗和标准化
**作为** 用户  
**我希望** 输入的商品名称能被自动清洗和标准化  
**以便** 提高匹配准确率

**验收标准**：
- [ ] 2.2.1 系统能移除演示机、礼盒等无关标记
- [ ] 2.2.2 系统能纠正常见拼写错误（如"雾松蓝"→"雾凇蓝"）
- [ ] 2.2.3 系统能展开缩写（如"GT5"→"Watch GT 5"）
- [ ] 2.2.4 系统能统一品牌名称（如"HUAWEI"→"华为"）
- [ ] 2.2.5 系统能标准化容量格式（如"8GB+256GB"→"8+256"）

### 2.3 信息提取
**作为** 系统  
**我希望** 从清洗后的输入中提取结构化信息  
**以便** 进行精确匹配

**验收标准**：
- [ ] 2.3.1 系统能提取品牌信息（支持中文和拼音）
- [ ] 2.3.2 系统能提取型号信息（标准化格式，与SPU预处理格式一致）
- [ ] 2.3.3 系统能提取颜色信息
- [ ] 2.3.4 系统能提取容量信息（内存+存储）
- [ ] 2.3.5 系统能提取版本信息（5G、全网通、活力版等）
- [ ] 2.3.6 每个提取结果都有置信度评分（0-1）

### 2.4 SPU精确匹配
**作为** 系统  
**我希望** 基于品牌+型号进行精确匹配  
**以便** 快速找到正确的SPU

**验收标准**：
- [ ] 2.4.1 品牌必须完全匹配（大小写不敏感）
- [ ] 2.4.2 型号必须完全匹配（标准化后比较，移除空格和特殊字符）
- [ ] 2.4.3 使用品牌索引快速过滤候选SPU（从全部→同品牌）
- [ ] 2.4.4 版本信息作为加分项，不作为必须条件
- [ ] 2.4.5 匹配分数 = 基础分(0.8) + 版本匹配分(0-0.2)

### 2.5 SPU优先级排序
**作为** 系统  
**我希望** 当多个SPU匹配分数相同时，能选择最合适的  
**以便** 返回最精确的匹配结果

**验收标准**：
- [ ] 2.5.1 分数更高的SPU优先
- [ ] 2.5.2 分数相同时，标准版优先于特殊版（礼盒版、套装版）
- [ ] 2.5.3 分数和版本类型相同时，名称更短（更精简）的SPU优先
- [ ] 2.5.4 精简度计算：移除品牌、型号、规格后的剩余字符数
- [ ] 2.5.5 系统能记录并展示选择理由

### 2.6 SKU匹配
**作为** 系统  
**我希望** 在匹配的SPU中找到最合适的SKU  
**以便** 返回完整的商品信息

**验收标准**：
- [ ] 2.6.1 基于颜色、容量、版本进行多维度匹配
- [ ] 2.6.2 根据产品类型调整权重（手机：颜色30%、容量40%、版本30%）
- [ ] 2.6.3 优先从SPU的skuIDs结构化数据中提取规格
- [ ] 2.6.4 SKU匹配分数 = Σ(维度分数 × 维度权重) / Σ(维度权重)
- [ ] 2.6.5 返回分数最高的SKU

### 2.7 模糊匹配（回退机制）
**作为** 系统  
**我希望** 当精确匹配失败时，能尝试模糊匹配  
**以便** 提高匹配成功率

**验收标准**：
- [ ] 2.7.1 仅在精确匹配失败或分数<0.99时触发
- [ ] 2.7.2 品牌仍然必须严格匹配
- [ ] 2.7.3 型号使用分词相似度计算（阈值≥0.5）
- [ ] 2.7.4 模糊匹配分数 = 0.4 + 型号相似度×0.6
- [ ] 2.7.5 模糊匹配结果需明确标注为"模糊匹配"

---

## 3. 功能需求

### 3.1 数据预处理模块

#### 3.1.1 SPU预处理
- **输入**：原始SPU列表（包含id, name, brand, skuIDs）
- **处理**：
  1. 提取品牌（优先使用brand字段，否则从name提取）
  2. 提取型号（移除品牌、容量、颜色后的核心部分）
  3. 标准化型号（小写、移除空格和特殊字符）
  4. 计算精简度（name长度 - 品牌长度 - 型号长度 - 规格长度）
- **输出**：增强的SPU对象
  ```typescript
  {
    id: number;
    name: string;
    brand: string;
    extractedBrand: string;      // 提取的品牌
    extractedModel: string;      // 提取的型号（标准化）
    normalizedModel: string;     // 标准化型号（用于匹配）
    simplicity: number;          // 精简度（越小越精简）
    skuIDs: SKUInfo[];
  }
  ```

#### 3.1.2 索引构建
- **品牌索引**：`Map<品牌名, SPU[]>`（支持中文和拼音）
- **型号索引**：`Map<标准化型号, SPU[]>`
- **规格索引**：`Map<规格值, SPU IDs>`（颜色、容量、版本）
- **频率索引**：按使用频率排序的规格列表

### 3.2 输入处理模块

#### 3.2.1 预处理流程
```
原始输入 
  → 清理（移除演示机、礼盒等标记）
  → 纠错（修正拼写错误）
  → 展开（缩写→全称）
  → 品牌别名映射（HUAWEI→华为）
  → 格式标准化（8GB+256GB→8+256）
  → 清洗后的输入
```

#### 3.2.2 信息提取
```
清洗后的输入
  → 提取品牌（匹配品牌库）
  → 提取型号（标准化格式）
  → 提取颜色（匹配颜色库）
  → 提取容量（内存+存储）
  → 提取版本（网络版本、特殊版）
  → 结构化信息对象
```

### 3.3 匹配模块

#### 3.3.1 精确匹配流程
```
1. 使用品牌索引过滤候选SPU
   输入品牌="华为" → 候选SPU = 品牌索引["华为"]
   
2. 遍历候选SPU，检查型号匹配
   输入型号标准化 = "mate60pro"
   SPU型号标准化 = "mate60pro"
   匹配 = (输入型号标准化 === SPU型号标准化)
   
3. 计算匹配分数
   基础分 = 0.8（品牌+型号匹配）
   版本匹配分 = 0-0.2（根据版本匹配情况）
   最终分数 = 基础分 + 版本匹配分
   
4. 排序选择最佳匹配
   优先级：分数 > 版本类型 > 精简度
```

#### 3.3.2 优先级排序规则
```typescript
function selectBestMatch(matches: SPUMatchResult[]): SPUMatchResult {
  return matches.sort((a, b) => {
    // 1. 分数更高优先
    if (a.score !== b.score) return b.score - a.score;
    
    // 2. 标准版优先
    if (a.priority !== b.priority) return b.priority - a.priority;
    
    // 3. 名称更短（更精简）优先
    if (a.spu.simplicity !== b.spu.simplicity) {
      return a.spu.simplicity - b.spu.simplicity;
    }
    
    return 0;
  })[0];
}
```

---

## 4. 非功能需求

### 4.1 性能要求
- [ ] 4.1.1 预处理10000个SPU耗时 < 5秒
- [ ] 4.1.2 单次匹配耗时 < 100ms
- [ ] 4.1.3 批量匹配100条记录耗时 < 10秒
- [ ] 4.1.4 内存占用 < 500MB

### 4.2 准确性要求
- [ ] 4.2.1 精确匹配准确率 ≥ 95%
- [ ] 4.2.2 整体匹配率 ≥ 90%
- [ ] 4.2.3 误匹配率 < 2%

### 4.3 可维护性要求
- [ ] 4.3.1 代码模块化，职责清晰
- [ ] 4.3.2 关键逻辑有详细注释
- [ ] 4.3.3 提供完整的单元测试
- [ ] 4.3.4 提供匹配过程日志

---

## 5. 约束条件

### 5.1 技术约束
- 使用TypeScript开发
- 运行在浏览器环境（Next.js）
- 不能使用外部AI服务

### 5.2 数据约束
- SPU数量：约10000+
- SKU数量：约50000+
- 品牌数量：约100+

### 5.3 兼容性约束
- 需要兼容现有的UI组件
- 需要兼容现有的数据结构

---

## 6. 验收标准

### 6.1 功能验收
- [ ] 所有用户故事的验收标准都通过
- [ ] 提供完整的测试用例和测试报告
- [ ] 提供匹配准确率统计报告

### 6.2 性能验收
- [ ] 所有性能指标都达标
- [ ] 提供性能测试报告

### 6.3 文档验收
- [ ] 提供完整的设计文档
- [ ] 提供完整的API文档
- [ ] 提供使用说明文档

---

## 7. 风险和依赖

### 7.1 风险
- **风险1**：型号提取规则可能无法覆盖所有情况
  - **缓解措施**：提供手动配置型号提取规则的机制
  
- **风险2**：预处理数据量大，可能影响启动速度
  - **缓解措施**：实现增量更新和缓存机制

### 7.2 依赖
- 依赖品牌数据库（getBrandBaseList）
- 依赖SPU/SKU数据（getSPUListNew, getSKUsInfo）
- 依赖配置文件（text-mappings.json）

---

## 8. 里程碑

| 里程碑 | 交付物 | 预计时间 |
|--------|--------|---------|
| M1: 需求确认 | 需求文档 | Day 1 |
| M2: 设计完成 | 设计文档 | Day 2-3 |
| M3: 开发完成 | 代码实现 | Day 4-7 |
| M4: 测试完成 | 测试报告 | Day 8-9 |
| M5: 上线部署 | 部署文档 | Day 10 |

---

## 9. 附录

### 9.1 术语表
- **SPU**：Standard Product Unit，标准产品单元
- **SKU**：Stock Keeping Unit，库存单元
- **精简度**：SPU名称中除核心信息外的冗余字符数
- **标准化**：将不同格式统一为一致格式的过程

### 9.2 参考资料
- 现有代码：`Z1P-Rnew/utils/services/`
- 配置文件：`Z1P-Rnew/public/.kiro/config/text-mappings.json`
